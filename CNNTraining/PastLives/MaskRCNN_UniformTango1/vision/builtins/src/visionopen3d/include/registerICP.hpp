///////////////////////////////////////////////////////////////////////////
// Copyright 2022-2023 The MathWorks, Inc.
///////////////////////////////////////////////////////////////////////////

#include "matrix.h"
#include "matrix/char_codecvt.hpp"

#include "registration.h"
#include "generalizedICP.h"
#include "coloredICP.h"

#include "open3d/geometry/PointCloud.h"
#include "open3d/geometry/KDTreeSearchParam.h"
#include "open3d/pipelines/registration/TransformationEstimation.h"

#ifdef _OPENMP
    #include <omp.h>
#endif

namespace o3dRegistration = open3d::pipelines::registration;
namespace o3dGeometry = open3d::geometry;

//////////////////////////////////////////////////////////////////////////////
// Check inputs.
//////////////////////////////////////////////////////////////////////////////
static void checkInputs(int nlhs, int nrhs, const mxArray *prhs[]);

//////////////////////////////////////////////////////////////////////////////
// Package outputs to send back to MATLAB.
//////////////////////////////////////////////////////////////////////////////
static void packageOutputs(o3dRegistration::RegistrationResult regResult,
                           int nlhs, mxArray *plhs[]);

//////////////////////////////////////////////////////////////////////////////
// Grid average downsampling and estimation of normals
//////////////////////////////////////////////////////////////////////////////
std::shared_ptr<open3d::geometry::PointCloud> gridAverageDownsampling(open3d::geometry::PointCloud ptCloud,double voxelSize);

//////////////////////////////////////////////////////////////////////////////
class ICPRegistrationImpl{
    o3dGeometry::PointCloud moving;
    o3dGeometry::PointCloud fixed;
    Eigen::Matrix4d initTform;
    bool useInlierRatio;
    bool verbose;
    bool useColor;
    double metric;
    std::vector<double> voxelSizes;
    std::vector<int> iterations;
    std::string method;
    o3dRegistration::ICPConvergenceCriteria convergenceCriteria;
    o3dRegistration::RegistrationResult regResult;

    int maxIteration;
    double relativeRotation;
    double relativeTranslation;
    bool useTransformationTolerance = true;

    //////////////////////////////////////////////////////////////////////////////
    // Parse registration options.
    //////////////////////////////////////////////////////////////////////////////
    void parseRegistrationOptions(const mxArray* prhs);

    //////////////////////////////////////////////////////////////////////////////
    // Parse inputs from the structure in mxArray.
    //////////////////////////////////////////////////////////////////////////////
    void parseInputs(const mxArray* prhs);

    //////////////////////////////////////////////////////////////////////////////
    // Read input point cloud locations from an mxArray.
    //////////////////////////////////////////////////////////////////////////////
    o3dGeometry::PointCloud readPointCloud(const mxArray* location);

    //////////////////////////////////////////////////////////////////////////////
    // Read normals from an mxArray.
    //////////////////////////////////////////////////////////////////////////////
    std::vector<Eigen::Vector3d> readNormals(const mxArray* mxNormals);

    //////////////////////////////////////////////////////////////////////////////
    // Read normalized colors from an mxArray.
    //////////////////////////////////////////////////////////////////////////////
    std::vector<Eigen::Vector3d> readNormalizedColors(const mxArray* mxColors);

    //////////////////////////////////////////////////////////////////////////////
    // Read voxel sizes from an mxArray.
    //////////////////////////////////////////////////////////////////////////////
    std::vector<double> readVoxelSizes(const mxArray* mxVoxelSizes);

    //////////////////////////////////////////////////////////////////////////////
    // Read the max iterations distribution for multi-scale registration from an mxArray.
    //////////////////////////////////////////////////////////////////////////////
    std::vector<int> readMaxIterations(const mxArray* mxIterations);

    //////////////////////////////////////////////////////////////////////////////
    // Read initial transformation from an mxArray.
    //////////////////////////////////////////////////////////////////////////////
    Eigen::Matrix4d readInitTform(const mxArray *prhs);

    //////////////////////////////////////////////////////////////////////////////
    // Read tolerance parameters from mxArray and construct ICPConvergenceCriteria.
    //////////////////////////////////////////////////////////////////////////////
    o3dRegistration::ICPConvergenceCriteria
        readConvergenceCriteria(const mxArray *prhs);

    //////////////////////////////////////////////////////////////////////////////
    // Helper function to call Open3D's API for point-to-point ICP.
    //////////////////////////////////////////////////////////////////////////////
    o3dRegistration::RegistrationResult registerUsingPointToPointICP();
    
    //////////////////////////////////////////////////////////////////////////////
    // Helper function to call Open3D's API for point-to-plane ICP.
    //////////////////////////////////////////////////////////////////////////////
    o3dRegistration::RegistrationResult registerUsingPointToPlaneICP();

    ////////////////////////////////////////////////////////////////////////////////
    // Helper function to call Open3D's API for color variant of point-to-plane ICP.
    ////////////////////////////////////////////////////////////////////////////////
    o3dRegistration::RegistrationResult registerUsingPointToPlaneWithColorICP();

    //////////////////////////////////////////////////////////////////////////////
    // Helper function to call Open3D's API for plane-to-plane ICP (Generalized-ICP).
    //////////////////////////////////////////////////////////////////////////////
    o3dRegistration::RegistrationResult registerUsingPlaneToPlaneICP();

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Helper function to call Open3D based implementation for color variant of plane-to-plane ICP (Generalized-ICP).
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    o3dRegistration::RegistrationResult registerUsingPlaneToPlaneWithColorICP();

    public:

    //////////////////////////////////////////////////////////////////////////////
    // Constructor
    //////////////////////////////////////////////////////////////////////////////
    ICPRegistrationImpl(const mxArray* prhs);
    
    //////////////////////////////////////////////////////////////////////////////
    // Helper function to perform registration based on the input method.
    //////////////////////////////////////////////////////////////////////////////
    o3dRegistration::RegistrationResult registerImpl();
};