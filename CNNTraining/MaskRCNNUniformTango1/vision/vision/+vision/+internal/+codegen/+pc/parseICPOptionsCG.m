%vision.internal.codegen.pc.parseICPOptionsCG Parse ICP algorithm options for codegen

% Copyright 2022-2023 The MathWorks, Inc.

%#codegen
function [metric, doExtrapolate, inlierRatio, inlierDistance, maxIterations, tolerance, ...
    initTform, verbose, useDegree] = parseICPOptionsCG(locationA, locationB, varargin)

defaults = struct(...
    'Metric', 'pointToPoint', ...
    'Extrapolate',  [], ...
    'InlierRatio', [],...
    'InlierDistance', [],...
    'MaxIterations', 30,...
    'Tolerance', [0.01, 0.5],...
    'InitialTransform', rigidtform3d([0 0 0], mean(locationB) - mean(locationA)),...
    'Verbose', false,...
    'UseDegree', true);

pvPairs = struct(...
    'Metric', uint32(0),...
    'Extrapolate', uint32(0),...
    'InlierRatio', uint32(0),...
    'InlierDistance', uint32(0),...
    'MaxIterations', uint32(0),...
    'Tolerance', uint32(0),...
    'InitialTransform', uint32(0),...
    'Verbose', uint32(0),...
    'UseDegree', uint32(0));

properties =  struct( ...
    'CaseSensitivity', false, ...
    'StructExpand',    true, ...
    'PartialMatching', false);

optarg = coder.internal.parseParameterInputs(pvPairs, properties, varargin{:});

metric = coder.internal.getParameterValue(optarg.Metric, defaults.Metric, varargin{:});
validateattributes(metric, {'char','string'}, {'scalartext'}, 'pcregistericp', 'Metric');
validatestring(metric, {'PointToPoint', 'PointToPlane', 'PlaneToPlane',...
    'pointToPlaneWithColor', 'planeToPlaneWithColor'}, 'pcregistericp', 'Metric');

doExtrapolateValue = coder.internal.getParameterValue(optarg.Extrapolate, defaults.Extrapolate, varargin{:});

if isempty(doExtrapolateValue) % Extrapolate is not specified by the user.
    doExtrapolate = false;
else % Extrapolate is specified by the user.
    warning(message('vision:pointcloud:extrapolateDeprecation'));
    doExtrapolate = doExtrapolateValue;
end

validateattributes(doExtrapolate, {'logical'}, {'scalar','nonempty'}, ...
    'pcregistericp', 'Extrapolate');

inlierDistance  = coder.internal.getParameterValue(optarg.InlierDistance, defaults.InlierDistance, varargin{:});
inputRatio      = coder.internal.getParameterValue(optarg.InlierRatio, defaults.InlierRatio, varargin{:});
coder.internal.errorIf(~isempty(inlierDistance) && ~isempty(inputRatio),'vision:pointcloud:inlierRatioOrDistance');
if ~isempty(inlierDistance)
    validateattributes(inlierDistance, {'single', 'double'}, ...
        {'scalar', 'real', 'positive', 'finite'}, ...
        'pcregistericp', 'InlierDistance');
end
if ~isempty(inputRatio)
    validateattributes(inputRatio, {'single', 'double'}, ...
        {'real','nonempty','scalar','>',0,'<=',1}, 'pcregistericp', 'InlierRatio');
end
if isempty(inlierDistance) && isempty(inputRatio)
    inlierRatio = 1.0;
else
    inlierRatio = inputRatio;
end

maxIterations   = coder.internal.getParameterValue(optarg.MaxIterations, defaults.MaxIterations, varargin{:});
validateattributes(maxIterations, {'single', 'double'}, ...
    {'real','scalar','integer','positive'}, 'pcregistericp', 'MaxIterations')

tolerance       = coder.internal.getParameterValue(optarg.Tolerance, defaults.Tolerance, varargin{:});
validateattributes(tolerance, {'single', 'double'}, ...
    {'real','nonnegative','numel', 2}, 'pcregistericp', 'Tolerance');

useDegree       = coder.internal.getParameterValue(optarg.UseDegree, defaults.UseDegree, varargin{:});
validateattributes(useDegree, {'logical'}, {'scalar','nonempty'}, ...
    'pcregistericp', 'UseDegree');

% verbose is not applicable for generated code, but however validated to maintain consistency
verboseIn = coder.internal.getParameterValue(optarg.Verbose, defaults.Verbose, varargin{:});
validateattributes(verboseIn, {'logical'}, {'scalar','nonempty'}, ...
    'pcregistericp', 'Verbose');

verbose = false;

initTform = coder.internal.getParameterValue(optarg.InitialTransform, defaults.InitialTransform, varargin{:});
validateattributes(initTform, {'rigidtform3d', 'rigid3d', 'affine3d'}, ...
    {'scalar'}, 'pcregistericp', 'InitialTransform')
coder.internal.errorIf(~(vision.internal.isRigidTransform(initTform.T)),'vision:pointcloud:rigidTransformOnly');
end