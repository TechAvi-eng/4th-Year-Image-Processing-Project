%groundTruthFromOpenLabel Convert OpenLABEL JSON file to groundTruth object
%
%   gTruth = groundTruthFromOpenLabel(jsonFile) converts  ASAM OpenLABEL formatted JSON file, jsonFile,
%   to groundTruth object, gTruth.
%
%   Notes:
%   ------
%   - ASAM OpenLABEL specification can be found there:
%     https://www.asam.net/index.php?eID=dumpFile&t=f&f=4566&token=9d976f840af04adee33b9f85aa3c22f2de4968dd
%   - groundTruthFromOpenLabel function is guaranteed to work with a JSON file produced by the groundTruthToOpenLabel
%     function but may not produce a valid or complete groundTruth object 
%     with files generated by third party tools. Please contact MathWorks 
%     technical support if you encounter such a situation.
%
%   Class support
%   -------------
%   jsonFilename must be a string pointing to a JSON file containing ground truth stored
%   in the ASAM OpenLABEL format. gTruth is a groundTruth object. 
%
%   Example
%   -------
%   % Add the folder containing images to the MATLAB path. It is necessary that the
%   % data files being labeled are available prior to creating the groundTruth object.
%
%   imageDir = fullfile(matlabroot, "toolbox", "vision", "visiondata", "vehicles");
%   addpath(imageDir);
%
%   data = load("vehicleTrainingGroundTruth.mat");
%   gTruthOriginal = data.vehicleTrainingGroundTruth;
%
%   % Convert the groundTruth object to JSON file in ASAM OpenLABEL format
%   groundTruthToOpenLabel(gTruthOriginal,"vehicleGtruthOpenLABEL");
%
%   % Convert JSON file in ASAM OpenLABEL format to a groundTruth object
%   gTruth = groundTruthFromOpenLabel("vehicleGtruthOpenLABEL.json");
%
%   % Inspect the ground truth data
%   imageLabeler(gTruth);
%
%   See also: groundTruth, imageLabeler, groundTruthToOpenLabel, jsondecode

% Copyright 2023-2024 The MathWorks, Inc.

function gTruth = groundTruthFromOpenLabel(jsonFilename)

% Parse function inputs
arguments
    jsonFilename {mustBeFile}
end

jsonText = fileread(jsonFilename);
gtStruct = jsondecode(jsonText);

%% Do rudimentary checks on the JSON file to verify that it's a valid OpenLABEL JSON.
validateOpenLabelJson(gtStruct);

%% Translate JSON file into groundTruth object

% Determine if we have a JSON holding video data.  Such file must have streams section.
isVideo = containsValidVideoStream(gtStruct);

% Create data source
[dataSource, hasRoisOrPixelLabels, hasSceneLabels] = constructSources(gtStruct, isVideo);

if isempty(dataSource) % This JSON file does not contain any labels
    error(message("vision:gtruthOpenLabel:emptyLabels"));
end

% Extract ROI-based label data and label definitions including sub-labels
% and attributes
if (hasRoisOrPixelLabels)
    [labelData, labelDefs] = constructLabelDataAndDefinitions(isVideo, gtStruct, dataSource);
else
    labelData = [];
    labelDefs = [];
end

% Extract scene labels
if hasSceneLabels
    [labelData, labelDefs] = constructSceneLabelDataAndDefinitions(isVideo, gtStruct, ...
        dataSource, labelData, labelDefs);
end

% Extract custom MathWorks data to augment label definitions if the JSON
% was generated using MathWorks tooling
[labelData, labelDefs] = extractCustomMathWorksData(gtStruct, labelData, labelDefs);
[labelData, labelDefs] = sanitizeVarNames(labelData, labelDefs);

gTruth = groundTruth(dataSource, labelDefs, labelData);

end

%-------------------------------------------------------------------------
% This sub-routine does a rudimentary check to verify that the JSON
% contains a video stream.
%-------------------------------------------------------------------------
function isVideo = containsValidVideoStream(gtStruct)

hasCamera = false;
hasStreams = isfield(gtStruct.openlabel, "streams");

if hasStreams
    % Cycle through the fields and make sure that we pick "camera" type.
    fields = fieldnames(gtStruct.openlabel.streams);
    for f=fields
        streamName = string(f); % strip cell array

        if isfield(gtStruct.openlabel.streams.(streamName), "type") && ...
            gtStruct.openlabel.streams.(streamName).type == "camera"
            hasCamera = true;
            break; % verify that at least one camera stream exists
        end
    end
end

isVideo = hasStreams && hasCamera;

end

%------------------------------------------------------------------------
% This routine replaces class names that may be invalid variable names 
% with their adjusted versions. This situation may happen with OpenLABEL
% files created outside of MathWorks tooling.
%------------------------------------------------------------------------
function [labelData, labelDefs] = sanitizeVarNames(labelData, labelDefs)

% Fix data table
originalNames = labelData.Properties.VariableNames;
sanitizedNames = matlab.lang.makeValidName(originalNames, 'ReplacementStyle', 'underscore');
labelData.Properties.VariableNames = sanitizedNames;

originalNames = labelDefs.Name;
sanitizedNames = matlab.lang.makeValidName(originalNames, 'ReplacementStyle', 'underscore');
labelDefs.Name = sanitizedNames;

end

%--------------------------------------------------------------------------
function validateOpenLabelJson(gtStruct)

if ~isfield(gtStruct, "openlabel")
    error(message("vision:gtruthOpenLabel:missingOpenlabelField"));
end

if ~isfield(gtStruct.openlabel, "metadata")
    error(message("vision:gtruthOpenLabel:missingOpenlabelMetadata"));
end

if ~isfield(gtStruct.openlabel.metadata, "schema_version")
    warning(message("vision:gtruthOpenLabel:missingSchemaVersion"));
else
    expectedSchema = "1.0.0";
    if gtStruct.openlabel.metadata.schema_version ~= expectedSchema
        warning(message("vision:gtruthOpenLabel:wrongSchemaVersion", ...
            gtStruct.openlabel.metadata.schema_version, expectedSchema));
    end
end

end

%--------------------------------------------------------------------------
% Note that the field names "shape" and "labels" are not universal. It may
% be necessary in the future to improve this code if we discover that
% image filenames may be stored under other branches of the OpenLABEL 
% data structures.
%--------------------------------------------------------------------------
function [dataSource, hasRoisOrPixelLabels, hasSceneLabels] = ...
    constructSources(gtStruct, isVideo)

% Grab source filenames from both objects (ROIs), pixel labels and contexts 
% (scene labels). Note that some sections may not exist.

hasRoisOrPixelLabels = isfield(gtStruct.openlabel, "objects");
hasSceneLabels       = isfield(gtStruct.openlabel, "contexts");

dataSource = []; % initialize to empty in case of failure

if isVideo
    % Video Labeler (single video) 

    fields = fieldnames(gtStruct.openlabel.streams);

    % Cycle through the fields and make sure that we pick "camera" type.
    % The multi-video scenario is currently unhandled until we find that
    % type of JSON file.  Therefore, we'll pick the first stream that
    % contains "camera" type.  GTL import will support multi-camera
    % scenario. Note that there is also a chance that the file may not 
    % contain a video stream. There is no special handling of this case 
    % in the code and it will end up failing naturally later in the code 
    % stack.
    for f=fields
        streamName = string(f); % strip cell array
        if gtStruct.openlabel.streams.(streamName).type == "camera"
            vidFilename = gtStruct.openlabel.streams.(streamName).uri;
            dataSource = groundTruthDataSource(vidFilename);
            break; % grab the first camera stream
        end
    end

else
    filenames = {};

    if  hasRoisOrPixelLabels
        % image filenames for images containing ROIs are under "shape" field
        roiFilenames = getAllFieldsPastWildcardField(gtStruct.openlabel.objects, ...
            "object_data_pointers", "shape", "uri");

        % image filenames for images containing pixel labels are under "labels" field
        pixLabelFilenames = getAllFieldsPastWildcardField(gtStruct.openlabel.objects, ...
            "object_data_pointers", "labels", "uri");

        filenames = horzcat(roiFilenames, pixLabelFilenames);
    end

    if hasSceneLabels % if it has scene labels
        sceneLabelFilenames = getAllFieldsPastWildcardField(gtStruct.openlabel.contexts, ...
            "context_data", "text", "val");
        filenames = horzcat(filenames, sceneLabelFilenames);
    end

    if hasRoisOrPixelLabels || hasSceneLabels
        filenames = unique(filenames)';
        dataSource = groundTruthDataSource(filenames);
    end
end

end

%--------------------------------------------------------------------------
function labelDefs = makeLabelDefs(labelDefsDict)

classNames = labelDefsDict.keys.cellstr;
val = labelDefsDict.values;

types     = [val.Type]';
hierarchy = {val.Hierarchy}';

% Columns in label definitions table
varNames = horzcat({'Name'}, fieldnames(val)');

hasPixelLabels = any(types == labelType("PixelLabel"));

if hasPixelLabels
    pixLabelIDs = {val.PixelLabelID}';
    packedInputs = {classNames, types, pixLabelIDs, hierarchy};
else
    packedInputs = {classNames, types, hierarchy};
end

labelDefs = table(packedInputs{:}, VariableNames=varNames);

end

%--------------------------------------------------------------------------
function [row, col] = getTableCellLocation(gtStruct, objID, dataSources)

gtObjStruct = gtStruct.openlabel.objects;

% Grab filenames
filenames = fixPathDelimiter(dataSources.Source);

if isFieldDescending(gtObjStruct.(objID), "object_data_pointers", "shape", "uri")
    preUriField = "shape";  % ROI objects
else    
    preUriField = "labels"; % Pixel label objects
end

fname =  getfield(gtObjStruct, objID, "object_data_pointers", preUriField, "uri");

% find location of a cell to populate in the output data table
row = find(filenames == string(fname));

classNameAtID = gtObjStruct.(objID).type;

varNames = getAllClasses(gtStruct);
col = find(varNames == string(classNameAtID));

end

%--------------------------------------------------------------------------
function [labelData, labelDefs] = ...
    constructLabelDataAndDefinitions(isVideo, gtStruct, dataSources)

% Extract all table variable names, in other words, object classes.
varNames = getAllClasses(gtStruct);
varNames(end+1) = {'Hierarchy'};
hasPixelLabels = logical(sum(contains(varNames, 'PixelLabelData')));

% Initialize dictionary for intermediate representation of label definitions
labelDefsDict = dictionary;

if isVideo
    numImages  = size(dataSources.TimeStamps, 1); % Images or frames in video
else
    filenames = fixPathDelimiter(dataSources.Source);
    numImages  = numel(filenames);
end

numClasses = numel(varNames);
data = repmat({struct("Position",{})}, [numImages, numClasses]);

%% Now fill the table with the actual data
gtObjStruct = gtStruct.openlabel.objects;

if isVideo
    numFrames = numImages; % for Video Labeler
    colTableDict = dictionary(varNames, 1:numClasses); % maps class name to column number
else
    numFrames = 1; % do not loop over frames (Image Labeler)
end

% Go over all video frames
for fnum = 1:numFrames

    if isVideo
        % pick next frame
        try
            fnum0 = fnum-1;
            gtFrameObjStruct = gtStruct.openlabel.frames.("x"+(fnum0)).objects;
        catch
            continue; % skip frames that were not labeled
        end
        objIDs = fieldnames(gtFrameObjStruct);
    else
        gtFrameObjStruct = []; % empty for images
        objIDs = fieldnames(gtObjStruct);
    end    

    isFirstWarning = true; % flag to reduce number of issued warnings

    % Cycle through the object fields
    for objIdx=1:numel(objIDs)

        % Flag to determine if we have sub-labels or attributes since that will
        % affect how we store the data in the ground truth object.
        hasHierarchy = false;

        objID = objIDs{objIdx};
        classNameAtID = gtObjStruct.(objID).type;

        if isVideo
            % determine the column of the table location to fill
            objDataAtID = gtFrameObjStruct.(objID).object_data;
        else            
            objDataAtID = gtObjStruct.(objID).object_data;
        end       

        % Go through objects and record them in a table
        [oltype, mwtype, convFcn, wasObjectFound] = findOpenLabelObjects(objDataAtID);

        if isVideo
            % determine the column of the table location to fill
            row = fnum;
            if gtObjStruct.(objID).type == "PixelLabel"
                col = colTableDict({'PixelLabelData'});
            else
                col = colTableDict({gtObjStruct.(objID).type});
            end
        else
            [row, col] = getTableCellLocation(gtStruct, objID, dataSources);
        end

        % encode the non-pixel label object
        if wasObjectFound

            % Convert ROI from OpenLABEL to gTruth format
            roi = objDataAtID.(oltype).val;
            % index to the conversion function is always
            % one for the main ROI but can be different for sub-ROIs
            roi = convFcn(roi);

            % write out label definition
            if ~labelDefsDict.isConfigured || ~labelDefsDict.isKey(classNameAtID)
                labelDefsDict(classNameAtID) = struct('Type', []);
            end

            labelDefsDict(classNameAtID).Type = labelType(mwtype);
            % write results to the LabelData table
            data = assignRoiToData(data, row, col, roi);

            if hasPixelLabels
                % Set to empty for non-pixel classes but only if pixel labels
                % are part of the data set in the first place
                labelDefsDict(classNameAtID).PixelLabelID = [];
            end
        else
            % Keep going.  It may still be a pixel label.
            if isfield(objDataAtID, "text")
                % Handle pixel labels
                oltype = "text"; % this is only for storing pixel label image locations
                mwtype = "PixelLabel";

                if gtObjStruct.(objID).type == mwtype
                    [data, labelDefsDict] = ...
                        encodePixelLabels(isVideo, mwtype, data, labelDefsDict, ...
                        gtStruct, gtFrameObjStruct, objID, row);
                else
                    % unexpected "text" field, but it doesn't mean that it's
                    % incorrect; skipping silently
                end
            else
                if isFirstWarning
                    warning("vision:gtruthOpenLabel:unsupportedObjData", ...
                        "Unsupported object_data section with the following fields: %s", ...
                        string(fields(objDataAtID)));
                    isFirstWarning = false;
                end
            end
        end

        % Prepare variables for attributes and sub-label processing.
        tCell = data(row, col); % extract existing entry
        if ~isempty(tCell)
            cellVal = tCell{:};
        else
            cellVal = [];
        end

        % This next if statement is for the case when there is an
        % object ID but it may not be associated with an ROI.
        % MathWorks labelers don't produce such data, but external JSON
        % files may contain this type of data.
        if ~labelDefsDict.isConfigured || ~labelDefsDict.isKey(classNameAtID)
            % Skip the rest of processing since this object doesn't have
            % an ROI associated with it. This essentially ignores this
            % data.
            continue; 
        end

        if (classNameAtID ~= "PixelLabel")
            if isfield(labelDefsDict(classNameAtID), "Hierarchy")
                hierarchy = labelDefsDict(classNameAtID).Hierarchy;
            else
                % Initialize description for the ROI to empty. It will be
                % updated if the custom MathWorks data for label definitions is
                % encoded in the JSON file.
                hierarchy = []; % reset the temp var
                hierarchy.Description = '';
            end
        end

        %% Process attributes
        if isfield(objDataAtID.(oltype), "attributes")
            hasHierarchy = true;

            attributes = objDataAtID.(oltype).attributes;

            [cellVal, hierarchy]  = extractAttributes(attributes, cellVal, hierarchy);

            % pack hierarchy into label definitions dictionary
            labelDefsDict(classNameAtID).Hierarchy = hierarchy;

            % pack the attributes into the table
            data(row, col) = {cellVal};
        end

        %% Process sub-labels
        if (classNameAtID ~= "PixelLabel") % pixel labels don't have children
            [cellVal, hierarchy, hasSublabels] = processSubLabels(objDataAtID, oltype, cellVal, hierarchy);
            if hasSublabels
                hasHierarchy = true;

                % pack hierarchy into label definitions dictionary
                labelDefsDict(classNameAtID).Hierarchy = hierarchy;

                % pack the attributes into the table
                data(row, col) = {cellVal};
            end
        end

        if hasHierarchy
            val = labelDefsDict(classNameAtID);
            labelDefsDict(classNameAtID).Hierarchy.Type = val.Type; % copy Type to hierarchy
        else
            if classNameAtID ~= "PixelLabel" % This is just a tag, not an actual class name
                if isVideo
                    if ~isfield(labelDefsDict(classNameAtID),"Hierarchy") % Don't wipe out existing hierarchy for video
                        labelDefsDict(classNameAtID).Hierarchy = [];
                    end
                else
                    labelDefsDict(classNameAtID).Hierarchy = [];
                end
            end
        end

    end
end % going over video frames

labelDefs = makeLabelDefs(labelDefsDict);

% Assign the data to our table
labelData = array2table(data, VariableNames=varNames);

% Strip unused table columns.  This can happen during code development when
% some types are not yet handled while a column was initialized to empty
% for the type that wasn't handled.
labelData = stripUnusedColumns(labelData);

% Simplify the representation for data that doesn't contain any
% hierarchical data, including attributes and sub-labels.
[labelData, labelDefs] = simplifyRepresentation(labelData, labelDefs);

end

%------------------------------------------------------------------------
function [cellVal, hierarchy]  = extractAttributes(attributes, cellVal, ...
    hierarchy, varargin)

if nargin == 4
    subRoiStruct = varargin{1};
    doSubAttributes = true;
else
    doSubAttributes = false;
end

allFields = fieldnames(attributes);

for fieldIdx = 1:numel(allFields)

    attrType = allFields{fieldIdx};

    for i=1:numel(attributes.(attrType))

        attribName = attributes.(attrType)(i).name;
        attribVal  = attributes.(attrType)(i).val;

        switch attrType
            case 'text'
                % 'text' could also be a list of strings in Labelers
                % but we don't know it without custom label data.  That
                % will be determined later.  This implementation is
                % generic.
                defaultValue = '';
            case 'num'
                defaultValue = [];
            case 'boolean'
                defaultValue = logical.empty;
            otherwise
                % skip any custom data that might have been placed at
                % this level
        end

        if doSubAttributes            
            % assign data to the table cell
            sublabelName = subRoiStruct.name;
            cellVal(end).(sublabelName)(end).(attribName) = attribVal;

            % update label definitions
            hierarchy.(sublabelName).(attribName).Description = '';
            hierarchy.(sublabelName).(attribName).DefaultValue = defaultValue;
        else
            % assign data to the table cell
            cellVal(end).(attribName) = attribVal;

            % update label definitions
            hierarchy.(attribName).Description = '';
            hierarchy.(attribName).DefaultValue = logical.empty;
        end

    end
end
end
%--------------------------------------------------------------------------
% This routine will handle the case of a singular object at the top level
% only. It is not intended for sub-labels.
%--------------------------------------------------------------------------
function [oltype, mwtype, convFcn, wasObjectFound] = ...
    findOpenLabelObjects(objData)

% Initialize the defaults
wasObjectFound = false;
oltype = string.empty;
mwtype = string.empty;
convFcn = function_handle.empty;

if isfield(objData, "bbox")
    oltype  = "bbox";
    mwtype  = "Rectangle";
    convFcn = @bbox2gtruth;
    wasObjectFound = true;
end

if isfield(objData, "rbbox")
    oltype = "rbbox";
    mwtype = "RotatedRectangle";
    convFcn = @rbbox2gtruth;
    wasObjectFound = true;
end

if isfield(objData, "point2d")
    oltype = "point2d";
    mwtype = "Point";
    convFcn = @point2gtruth;
    wasObjectFound = true;
end

if isfield(objData, "poly2d")
    % This section handles polygons, lines and projected cuboids which
    % are all encoded into poly2d
    oltype = "poly2d";
    isPolyClosed = objData.poly2d.closed;

    if isfield(objData.poly2d, "matlab_projected_cuboid")
        isProjCuboid = objData.poly2d.matlab_projected_cuboid;
    else
        isProjCuboid = false;
    end

    if isProjCuboid
        mwtype = "ProjectedCuboid";
        convFcn = @projcuboid2gtruth;
    else
        if isPolyClosed
            mwtype = "Polygon";
        else
            mwtype = "Line";
        end
        convFcn = @point2gtruth;
    end

    wasObjectFound = true;
end

end

%----------------------------------------------------------------------
function [data, labelDefsDict, className] = encodePixelLabels(isVideo, ...
    mwtype, data, labelDefsDict, gtStruct, gtFrameObjStruct, objID, row)

gtObjStruct = gtStruct.openlabel.objects;
varNames    = getAllClasses(gtStruct);
className   = string.empty;

% handle data
pixLabelVarName = "PixelLabelData";

col = (varNames == pixLabelVarName); % logical index
if isVideo
    pixFilename = gtFrameObjStruct.(objID).object_data.text.val;
else
    pixFilename = gtObjStruct.(objID).object_data.text.val;
end

data(row, col) = {pixFilename};

% Extract and record pixel label ID to class name correspondences
if isfield(gtStruct.openlabel.metadata, "matlab_label_definitions")

    for ldefIdx = 1:numel(gtStruct.openlabel.metadata.matlab_label_definitions)
        if gtStruct.openlabel.metadata.matlab_label_definitions(ldefIdx).val.Type == mwtype
            className = gtStruct.openlabel.metadata.matlab_label_definitions(ldefIdx).val.Name;
            val.Type = labelType(mwtype);
            val.PixelLabelID = gtStruct.openlabel.metadata.matlab_label_definitions(ldefIdx).val.PixelLabelID;
            val.Hierarchy = []; % pixel labels don't have a hierarchy
            labelDefsDict(className) = val;
        end
    end
else
    error(message("vision:gtruthOpenLabel:missingMatlabLabelDefs"));
end

end

%--------------------------------------------------------------------------
function data = assignRoiToData(data, row, col, roi)

tCell = data(row, col);
if isempty(tCell{:})
    cellVal.Position = roi;
else
    cellVal = tCell{:};
    f = fieldnames(cellVal);
    for objIdx=1:numel(f)
        % replicate fields and initialize to empty
        addendumCellVal.(f{objIdx}) = [];
    end

    addendumCellVal.Position = roi;
    cellVal = horzcat(cellVal,addendumCellVal); % row vector
end
data(row, col) = {cellVal}; % assign the table entry

end

%--------------------------------------------------------------------------
function [cellVal, hierarchy, hasSublabels] = processSubLabels(objDataAtID, ...
    mainoltype, cellVal, hierarchy)

% reach beyond initial object_data
subObjData = objDataAtID.(mainoltype);

structFields = fields(subObjData);
numFields = numel(structFields);

hasSublabels = false;

for fieldNum = 1:numFields

    field = string(structFields{fieldNum});

    switch field
        case "bbox"
            oltype  = "bbox";
            mwtype  = "Rectangle";
            convFcn = @bbox2gtruth;
            
            hasSublabels = true;

            processSublabelsOfSameType;
        case "rbbox"
            oltype = "rbbox";
            mwtype = "RotatedRectangle";
            convFcn = @rbbox2gtruth;

            hasSublabels = true;

            processSublabelsOfSameType;
        case "point2d"
            oltype  = "point2d";
            mwtype  = "Point";
            convFcn = @point2gtruth;

            hasSublabels = true;

            processSublabelsOfSameType;
        case "poly2d"
            oltype = "poly2d";

            hasSublabels = true;
            
            numSublabelsOfSameOlType = numel(subObjData.(oltype));
            for polysublabelIdx = 1:numSublabelsOfSameOlType

                % This section handles polygons, lines and projected cuboids which
                % are all encoded into poly2d
                if isstruct(subObjData.(oltype))
                    currentRoi = subObjData.(oltype)(polysublabelIdx);
                else                    
                    currentRoi = subObjData.(oltype){polysublabelIdx};
                end

                isPolyClosed = currentRoi.closed;

                if isfield(currentRoi, "matlab_projected_cuboid")
                    isProjCuboid = currentRoi.matlab_projected_cuboid;
                else
                    isProjCuboid = false;
                end

                if isProjCuboid
                    mwtype = "ProjectedCuboid";
                    convFcn = @projcuboid2gtruth;
                else
                    if isPolyClosed
                        mwtype = "Polygon";
                    else
                        mwtype = "Line";
                    end
                    convFcn = @point2gtruth;
                end

                % This packing can happen for poly2d where the structures
                % may be non-uniform, containing varying fields
                roiName = currentRoi.name;
                roiVal  = currentRoi.val;

                roiVal  = convFcn(roiVal);

                % fill up info for sub-label
                if isfield(cellVal(end), roiName)
                    cellVal(end).(roiName)(end+1).Position = roiVal; % assign to the table cell
                else
                    cellVal(end).(roiName)(1).Position = roiVal; % assign to the table cell
                end

                % append attributes
                if isfield(currentRoi, "attributes")
                    attributes = currentRoi.attributes;
                    [cellVal, hierarchy]  = extractAttributes(attributes, cellVal, hierarchy, currentRoi);
                end

                % update label definitions
                hierarchy.(roiName).Type = labelType(mwtype);
                hierarchy.(roiName).Description = '';

            end
        otherwise
            % ignore non-ROI fields
    end
end

    function processSublabelsOfSameType
            numSublabelsOfSameOlType = numel(subObjData.(oltype));
            for sublabelIdx = 1:numSublabelsOfSameOlType

                currentRoi = subObjData.(oltype)(sublabelIdx);

                roiName = currentRoi.name;
                roiVal  = currentRoi.val;

                roiVal  = convFcn(roiVal);

                % fill up info for sub-label
                if isfield(cellVal(end), roiName)
                    cellVal(end).(roiName)(end+1).Position = roiVal; % assign to the table cell
                else
                    cellVal(end).(roiName)(1).Position = roiVal; % assign to the table cell
                end

                % append attributes
                if isfield(currentRoi, "attributes")
                    attributes = currentRoi.attributes;
                    [cellVal, hierarchy]  = extractAttributes(attributes, cellVal, hierarchy, currentRoi);
                end

                % update label definitions
                hierarchy.(roiName).Type = labelType(mwtype);
                hierarchy.(roiName).Description = '';

            end
    end


end

%--------------------------------------------------------------------------
function out = stripUnusedColumns(in)

out = in;

numCol = size(in,2);
headings = in.Properties.VariableNames;

for n = 1:numCol
    col = table2cell(in(:,n));
    isEmpty = all(cellfun(@isempty, col));

    if isEmpty
        out = removevars(out, headings{n});
    end
end

end

%--------------------------------------------------------------------------
function bboxout = bbox2gtruth(bboxin)

bboxout = bboxin';

% convert to UL corner 1-based; height and width remain unchanged
bboxout(1) = bboxin(1) - bboxin(3)/2 + 1;
bboxout(2) = bboxin(2) - bboxin(4)/2 + 1;

end

%--------------------------------------------------------------------------
function rbboxout = rbbox2gtruth(rbboxin)

rbboxout = rbboxin';

% Adjust bbox center to be in 0-based coordinate system
rbboxout(1) = rbboxin(1) + 1;
rbboxout(2) = rbboxin(2) + 1;

% width and height remain unchanged

% rotation must be in degrees
rbboxout(5) = rad2deg(rbboxin(5));

end

%--------------------------------------------------------------------------
function pointsout = point2gtruth(pointsin)

% rearrange the points to [x1,y1;x2,y2;....; xn,yn]
points = reshape(pointsin, 2, []);
points = points';

% 1-based indexing
pointsout = points + 1;

end

%--------------------------------------------------------------------------
function rectsout = projcuboid2gtruth(pointsin)

points = point2gtruth(pointsin); % gTruth style points
rectsout = points2rects(points);

end

%--------------------------------------------------------------------------
function rects = points2rects(points)

    % rect 1
    ul1 = points(1,:);      % upper left x,y
    w1h1 = points(3,:)-ul1; % [w h]
    
    % rect 2
    ul2 = points(5,:);      % upper left x,y
    w2h2 = points(7,:)-ul2; % [w h]

    rects = [ul1 w1h1, ul2 w2h2]; % representation of a projected cuboid (two rectangles)
end

%--------------------------------------------------------------------------
function classes = getAllClasses(gtStruct)

classes = getAllFieldsPastWildcardField(gtStruct.openlabel.objects, "type");
classes = unique(classes);

% Pixel labels are special.  Replace the pixel label column from above with
% "PixelLabelData"
classes = strrep(classes, 'PixelLabel', 'PixelLabelData');

hasPixelLabels = logical(sum(contains(classes, 'PixelLabelData')));
if hasPixelLabels
    % make pixel label data the last column since it is wide and pollutes
    % the display of the table when it's in the first column
    classes(1:end) = horzcat(classes(2:end), classes(1));
end

end

%--------------------------------------------------------------------------
% You can pass a branch of a struct to this function and ask it to extract
% all fields at a particular level and return them stuffed into a cell
% array. The branch should be up to a wildcard field and the rest of the
% fields must be in a cell array.  Search code for example usage to
% understand it better.
%--------------------------------------------------------------------------
function out = getAllFieldsPastWildcardField(gtSubStruct, varargin)

f = fieldnames(gtSubStruct);
out = {}; % initialize to empty
for i=1:numel(f)
    if isFieldDescending(gtSubStruct.(f{i}), varargin{:})
        out{end+1} = getfield(gtSubStruct, f{i}, varargin{:}); %#ok<AGROW>
    end
end

end

%--------------------------------------------------------------------------
% Use recursion to see if a field exist.  This is tricky.
%--------------------------------------------------------------------------
function out = isFieldDescending(subStruct, varargin)

if nargin > 2
    if isfield(subStruct.(varargin{1}), varargin{2})
        out = isFieldDescending(subStruct.(varargin{1}), varargin{2:end});
    else
        out = false;
    end
else
    out = isfield(subStruct, varargin{1});
end

end

%------------------------------------------------------------------------
function [labelData, labelDefs] = constructSceneLabelDataAndDefinitions(...
    isVideo, gtStruct, dataSource, labelData, labelDefs)

 sceneClasses = getAllSceneClasses(gtStruct);

if isempty(sceneClasses)
    return; % this happens if there is no "contexts" section; no scene labels
end

if isVideo
    numRows = size(dataSource.TimeStamps, 1); % this is number of frames
else
    filenames = fixPathDelimiter(dataSource.Source);
    numRows = numel(filenames);
end

numCols = numel(sceneClasses);

% initialize scene label table
data = cell(numRows, numCols);

gtContextStruct = gtStruct.openlabel.contexts;
contextFields = fieldnames(gtContextStruct);

hasSceneLabels = false;

% Cycle through the object fields
for contextIdx=1:numel(contextFields)

    contextID = contextFields{contextIdx};

    contextAtID = gtContextStruct.(contextID);
    contextData = contextAtID.context_data;
    
    % class and its logical value
    objClass   = contextAtID.type;

    if isfield(contextData, "boolean")
        % Some non-MathWorks JSON files may not have boolean scene labels
        % but may still contain valid entries in the contexts section.
        hasSceneLabels = true;         
    else
        % Protect against importing data unsupported by the labelers. Only
        % boolean labels are currently supported. Some non-MathWorks JSON
        % files may contain non-boolean entries.

        % Remove classes that are non-boolean; do it once        
        remIdx = sceneClasses == string(objClass);
        if any(remIdx)
            sceneClasses(remIdx) = [];
            numCols = numCols-1; % reduce number of classes in the final table
        end

        continue;
    end

    logicalVal = contextData.boolean.val;

    if isVideo
        % determine the row based on frame_start and frame_end
        frameNumberZeroBased = contextAtID.frame_intervals(1).frame_start;
        row = frameNumberZeroBased+1;
        col = find(string(sceneClasses) == objClass);
    else
        imageFilename = contextData.text.val;
        [row, col] = getSceneTableCellLocation(filenames, imageFilename, sceneClasses, objClass);
    end
    data{row,col} = logicalVal;
end

if ~hasSceneLabels
    % Stop right here if only non-boolean entries were found.  These are
    % currently not supported by the labeler apps.
    return
end

sceneLabelTable = cell2table(data, VariableNames=sceneClasses);

% Update label data table
labelData = [labelData, sceneLabelTable];

% Update label definitions table
mwType = labelType("Scene");
numSceneLabels = numCols;

% Add the first two columns defining class and type which are always present
labelDefsAddition = [sceneClasses', repmat({mwType}, [numSceneLabels,1])];

% Add additional columns if necessary (might contain hierarchy, pixel label ID).
% Both of these must be empty for scene labels.
numDefColumns = size(labelDefs, 2);
if numDefColumns-2 > 0    
    additionalCols = numDefColumns-2;
    labelDefsAddition = [labelDefsAddition, repmat({double.empty}, ...
        [numSceneLabels,additionalCols])];
end

if ~isempty(labelDefs)
    labelDefs = [labelDefs; labelDefsAddition];
else % no ROI or pixel labels
    labelDefs = cell2table(labelDefsAddition, 'VariableNames', {'Name','Type'});
end

end

%------------------------------------------------------------------------
function classes = getAllSceneClasses(gtStruct)

if isfield(gtStruct.openlabel, "contexts")
    classes = getAllFieldsPastWildcardField(gtStruct.openlabel.contexts, "type");
    classes = unique(classes);
else
    classes = [];
end

end

%--------------------------------------------------------------------------
function [row, col] = getSceneTableCellLocation(filenames, imageFilename, sceneClasses, objClass)

row = find(string(filenames) == imageFilename);
col = find(string(sceneClasses) == objClass);

end

%--------------------------------------------------------------------------
function [labelData, labelDefs] = simplifyRepresentation(labelData, labelDefs)

hierarchyColumn = labelDefs{:, "Hierarchy"};

% Check if Hierarchy is fully empty
isAllHierarchyEmpty = all(cellfun(@isempty, hierarchyColumn));

if isAllHierarchyEmpty
    % Strip out hierarchy column from label definitions
    labelDefs = removevars(labelDefs, "Hierarchy");

    % Extract Positions from hierarchical structure of label data.  At this
    % stage we don't yet have scene labels.  PixelLabelData column should
    % be omitted.
    columnHeadings = labelData.Properties.VariableNames;
    
    % get rid of pixel label heading
    rmidx = (columnHeadings == "PixelLabelData");
    columnHeadings(rmidx) = [];

    for headingIdx = 1:numel(columnHeadings)
        heading = columnHeadings{headingIdx};
        dataColumn = labelData{:, heading};

        for m=1:numel(dataColumn)
            cellVal = dataColumn{m};            
            
            logicalRowIdx = labelDefs{:, "Name"} == string(heading);
            roiType = labelDefs{logicalRowIdx, "Type"};
            
            if roiType == "Polygon" || roiType == "Line"
                dataColumn(m) = {{cellVal.Position}'};
            else
                dataColumn(m) = {vertcat(cellVal.Position)};
            end
        end

        % Replace with the simplified column
        labelData{:, heading} = dataColumn;
    end

end

end

%--------------------------------------------------------------------------
function [labelData, labelDefsNew] = extractCustomMathWorksData(gtStruct, ...
    labelData, labelDefs)

% Check if custom data exists, bail if it doesn't
if ~isfield(gtStruct.openlabel.metadata, "matlab_label_definitions")    
    labelDefsNew = labelDefs;
    return % nothing to extract
end

%% Update label definitions

% Just grab the first item to establish label definition table column names
item = gtStruct.openlabel.metadata.matlab_label_definitions(1);
defColNamesStored = fieldnames(item.val)';
defColNamesCurrent = labelDefs.Properties.VariableNames;

numAdditionalCols = numel(defColNamesStored) - numel(defColNamesCurrent);
numRowsCurrent = size(labelDefs,1);

% Initialize new table cells
newData = cell(numRowsCurrent, numAdditionalCols);

% What are the column names that we need to add?
tf = ismember(defColNamesStored, defColNamesCurrent);
newColumnNames = defColNamesStored(~tf);

% initialize variables for the case of having new labels not yet processed
newLabelDefinitionsIdx = [];

for idx = 1:numel(gtStruct.openlabel.metadata.matlab_label_definitions)

    item = gtStruct.openlabel.metadata.matlab_label_definitions(idx);

    rowDefsIdx = (labelDefs.Name == string(item.name));

    if any(rowDefsIdx) % matching entry with existing labels

        for colNewIdx = 1:numAdditionalCols
            colName = newColumnNames{colNewIdx};
            % Fill missing column entries in label definitions
            if colName == "LabelColor"
                color = item.val.(colName);
                newData{rowDefsIdx, colNewIdx} = color(:)'; % always a row vector
            else
                newData{rowDefsIdx, colNewIdx} = item.val.(colName);
            end
        end

    else % no entry in existing set of labels

        % This is a case where a definition exists but it was never used to
        % mark up the actual data in one of the labeler apps
        newLabelDefinitionsIdx = [newLabelDefinitionsIdx, idx]; %#ok<AGROW>
    end

end

% Update the output label definition table
newEntriesTable = cell2table(newData, VariableNames=newColumnNames);
% Order of columns must be: Name, Type, LabelColor, PixelLabelID, Group,
% Description, Hierarchy. It's required.

% Add the always present fields first, then sequentially add others
labelDefsNew = [labelDefs(:,"Name"), labelDefs(:,"Type")];

if ismember("LabelColor", newColumnNames)
    labelDefsNew = [labelDefsNew, newEntriesTable(:,"LabelColor")];
end
    
if ismember("PixelLabelID", defColNamesCurrent)
    labelDefsNew = [labelDefsNew, labelDefs(:,"PixelLabelID")];
end
    
if ismember("Group", newColumnNames)
    labelDefsNew = [labelDefsNew, newEntriesTable(:,"Group")];
end

if ismember("Description", newColumnNames)
    labelDefsNew = [labelDefsNew, newEntriesTable(:,"Description")];
end

hasHierarchy = ismember("Hierarchy", defColNamesCurrent);
if hasHierarchy
    labelDefsNew = [labelDefsNew, labelDefs(:,"Hierarchy")];
end

% Affix missing label definitions
if ~isempty(newLabelDefinitionsIdx)

    defColNamesNew = labelDefsNew.Properties.VariableNames;
    numNewRows = numel(newLabelDefinitionsIdx);
    numNewCols = numel(defColNamesNew);
    
    dataRows = cell(numNewRows, numNewCols);

    for m = 1:numNewRows
        item = gtStruct.openlabel.metadata.matlab_label_definitions(newLabelDefinitionsIdx(m));
        for n = 1:numNewCols
            if defColNamesNew{n} == "LabelColor"
                color = item.val.(defColNamesNew{n});
                dataRows{m, n} = color(:)'; % always a row vector
            else
                dataRows{m, n} = item.val.(defColNamesNew{n});
            end
        end
    end

    % append new data rows
    labelDefsNew = [labelDefsNew;dataRows];
end

% Since we have the custom MathWorks data, we can fully restore the
% original order of the definitions, just for round-trip conversion
% consistency.
originalOrder = string({gtStruct.openlabel.metadata.matlab_label_definitions.name}');
currentOrder = string(labelDefsNew.Name);

numDefs = length(originalOrder);

for idx = 1:numDefs
    sortIdx(idx) = find(originalOrder(idx) == currentOrder);
end

labelDefsNew = labelDefsNew(sortIdx, :);

% Ordering of entries and missing label definitions also affect full
% restoration of the Hierarchy column. We can cycle through it and
% restore it perfectly.
if hasHierarchy
    for idx = 1:numDefs
        item = gtStruct.openlabel.metadata.matlab_label_definitions(idx);
        hierarchy = item.val.Hierarchy;
        if isstruct(hierarchy) % update items for non-empty hierarchies
            hierarchy = transposeListItemsAndColor(hierarchy);
            hierarchy = fixDefaultValueAndType(hierarchy);
        end

        labelDefsNew.Hierarchy{idx} = hierarchy;

    end
end
    function structOut = transposeListItemsAndColor(structIn)
        % This function recursively transposes all 'ListItems' fields in
        % the input structure. Upon round trip with json
        % encode/decode the row vectors are flipped to column vectors. This
        % is corrected here to make the round trip perfect for the label
        % definitions table.

        % Initialize the output structure
        structOut = structIn;

        % Iterate over each field of the structure
        fields = fieldnames(structIn);
        for i = 1:length(fields)
            fieldName = fields{i};
            fieldValue = structIn.(fieldName);

            % Check if the current field is 'ListItems'
            if strcmp(fieldName, 'ListItems') || strcmp(fieldName, 'LabelColor')
                % Transpose 'ListItems' if it is a matrix or a cell array
                if ismatrix(fieldValue) || iscell(fieldValue)
                    structOut.(fieldName) = fieldValue';
                end
            elseif isstruct(fieldValue)
                % If the field is a structure, recursively call this function
                if isscalar(fieldValue)
                    % Single struct
                    structOut.(fieldName) = transposeListItemsAndColor(fieldValue);
                else
                    % Array of structs
                    for j = 1:numel(fieldValue)
                        structOut.(fieldName)(j) = transposeListItemsAndColor(fieldValue(j));
                    end
                end
            end
        end
    end

    function structOut = fixDefaultValueAndType(structIn)
        % This function recursively expands 'DefaultValue' that's encoded
        % with a class, e.g. "logical([])" to an actual value with the
        % correct class eval("logical([])"). The encoding happens inside
        % the groundTruthToOpenLabel() function.  Additionally, Type field
        % is cast to labeType from string class.

        % Initialize the output structure
        structOut = structIn;

        % Iterate over each field of the structure
        fields = fieldnames(structIn);
        for i = 1:length(fields)
            fieldName = fields{i};
            fieldValue = structIn.(fieldName);

            % Check if the current field is 'DefaultValue' or 'Type'
            if strcmp(fieldName, 'DefaultValue') || strcmp(fieldName, 'Type')
                % Convert char to string if it is a char array
                if strcmp(fieldName, 'DefaultValue')
                    % convert to properly valued class
                    structOut.(fieldName) = eval(fieldValue);                    
                else
                    % It's Type field. Just cast to labelType class.
                    structOut.(fieldName) = labelType(fieldValue);
                end
            elseif isstruct(fieldValue)
                % If the field is a structure, recursively call this function
                if isscalar(fieldValue)
                    % Single struct
                    structOut.(fieldName) = fixDefaultValueAndType(fieldValue);
                else
                    % Array of structs
                    for j = 1:numel(fieldValue)
                        structOut.(fieldName)(j) = fixDefaultValueAndType(fieldValue(j));
                    end
                end
            end
        end
    end

end

%--------------------------------------------------------------------------
function pathOut = fixPathDelimiter(pathIn)

pathOut = strtrim(strrep(pathIn,'\','/'));

end

